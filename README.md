Асинхронный Telegram-бот для оператора поддержки с разграничением ролей, сессионной моделью диалогов и журналированием сообщений в БД.

### Ключевые возможности

- **Сессии**: создание, назначение оператору, закрытие, список закрытых.
- **Логирование**: запись каждого сообщения пользователя/оператора.
- **Вложения**: поддержка файлов, фото, голосовых.
- **Админ-функции**: управление из панели и колбэков.

## Быстрый старт

1. Установка зависимостей

```bash
uv sync
```

2. Переменные окружения (пример `.env`)

```env
TOKEN=your_telegram_bot_token
ADMINS_ID=123456789,987654321
DB_HOST=localhost
DB_USER=your_db_user
DB_PASSWORD=your_db_password
DB_DATABASE=onyxchat
```

3. Запуск

```bash
uv run python main.py
```

При старте вызывается `DatabaseService.create_tables()` — необходимые таблицы будут созданы, если их нет.

## Как устроено приложение

### Поток обработки

1. Сообщение попадает в `aiogram`-диспетчер `Dispatcher` → подключённые `middlewares`.
2. Middleware добавляют в контекст контейнер сервисов (`ServiceContainer`), логируют и проверяют права.
3. Хендлеры (`handlers/`) вызывают методы сервисов, не обращаясь напрямую к БД.
4. Сервисы выполняют SQL через пул `aiomysql` и возвращают данные/результаты.

### Сервисы (`services/`)

- `ServiceContainer` — единая точка доступа к сервисам (ленивая инициализация, общий пул БД и бот).
- `DatabaseService` — создание таблиц, проверка подключения, базовая информация о БД.
- `UserService` — операции над пользователями (создание/обновление текущей сессии и т.п.).
- `SessionService` — обеспечение/создание сессий, назначение операторов, закрытие, выборки.
- `MessageService` — логирование сообщений, выборка истории, получение `file_id`.
- `NotificationService` — отправка уведомлений через бота (уведомления операторам и т.п.).

Каждый сервис наследуется от `BaseService` и получает доступ к `self.pool` (пул соединений) и `self.logger`.

### SQL вынесен по модулям (`sql/`)

- `database_sql.py` — SQL для создания таблиц (`create_*_table`).
- `user_sql.py` — SQL для пользователей (`add_user`, `bind_current_session_to_user`).
- `session_sql.py` — SQL для сессий (`openCreate_session`, `find_open_session`, `assign_session`, `close_session`, выборки и подсчёты закрытых сессий и т.д.).
- `message_sql.py` — SQL для сообщений (`log_message`, `fetch_session_messages`, `get_message_file`).

## Структура проекта (сокращённо)

```
onyxChat/
├── handlers/            # Обработчики сообщений и колбэков
├── keyboards/           # Клавиатуры
├── middlewares/         # Проверки прав, логирование, добавление пользователей
├── services/            # Бизнес-логика (сервисы)
│   ├── base_service.py
│   ├── container.py
│   ├── database_service.py
│   ├── message_service.py
│   ├── notification_service.py
│   ├── session_service.py
│   └── user_service.py
├── sql/                 # SQL, разделённый по доменам
│   ├── database_sql.py
│   ├── message_sql.py
│   ├── session_sql.py
│   └── user_sql.py
├── utils/               # Логгер и утилиты
├── main.py              # Точка входа (инициализация пула, сервисов, роутеров)
└── config.py            # Конфигурация и создание пула БД
```

## Жизненный цикл запроса (пример)

1. Пользователь пишет в бота → Middleware логирует и добавляет контейнер сервисов.
2. Хендлер вызывает `SessionService.ensure_open_session(tgid)`.
3. При необходимости создаётся сессия и привязывается к пользователю (`UserService.update_user_session`).
4. Сообщение сохраняется через `MessageService.log_message`.
5. Оператор может взять сессию (`SessionService.assign_session`) и затем закрыть (`SessionService.close_session`).

## Как добавлять новую бизнес-логику

1. Определите домен (пользователь/сессия/сообщение/инфраструктура БД).
2. Добавьте SQL-константы в соответствующий модуль `sql/*.py`.
3. Добавьте методы в соответствующий сервис в `services/*.py` и используйте эти SQL-константы.
4. В хендлере вызывайте метод сервиса. Не ходите в БД напрямую из хендлеров/мидлварей.

## Лицензия

MIT License
